"use strict";

function multiple(length, limit) {
    var space = "";
    if (length > limit) return space;
    for (var i = 0, ii = limit - length; ii > i; ++i) space += " ";
    return space;
}

function error(e) {
    return isNaN(e) === !1 ? new Error(status[e]) : new Error("ENAMETOOLONG" === e.code ? status[414] : status[404]);
}

function pad(num) {
    var norm = Math.abs(Math.floor(num));
    return (10 > norm ? "0" : "") + norm;
}

function wrapper(my) {
    function output(res, head, after, paths, stat) {
        my.json === !0 ? (res.send(head), STORY.body = head) : (head += after + footer, 
        res.send(head), STORY.body = head), my.cache === !0 && (STORY.path = paths, STORY.mtime = stat.mtime.getTime());
    }
    function json(head, after, file, stats) {
        var size, fil = file;
        if (stats.isDirectory() === !0 ? (size = "-", fil += "/") : size = String(stats.size), 
        head[fil] = Object.create(null), my.date === !0) {
            var d = new Date(stats.mtime), h = pad(d.getDate()) + "-" + month[d.getMonth()] + "-" + d.getFullYear();
            h += " " + pad(d.getHours()) + ":" + pad(d.getMinutes()), head[fil].mtime = h;
        }
        return my.size === !0 && (head[fil].size = size), [ head, null ];
    }
    function html(head, after, file, stats) {
        var h, size, hea = head, afte = after, fil = file;
        if (stats.isDirectory() === !0 ? (size = "-", fil += "/") : size = String(stats.size), 
        h = '<a href="' + fil + '">' + fil + "</a>", h += multiple(fil.length, 50), my.date === !0) {
            var d = new Date(stats.mtime);
            h += pad(d.getDate()) + "-" + month[d.getMonth()] + "-" + d.getFullYear(), h += " " + pad(d.getHours()) + ":" + pad(d.getMinutes()), 
            h += multiple(size.length, 20);
        }
        return my.size === !0 && (h += size), h += "\n", my.priority === !0 ? "-" === size ? hea += h : afte += h : hea += h, 
        [ hea, afte ];
    }
    var STORY = Object.create(null), build = html;
    return my.json === !0 && (build = json), my.sync === !0 ? function(req, res, next) {
        if (my.strictMethod === !0 && "GET" !== req.method && "HEAD" !== req.method) return next(error(404));
        var paths = decodeURIComponent(parse(req).pathname).replace(/\/{2,}/, "/"), prova = path.normalize(path.join(my.root, paths));
        if (~prova.indexOf("\x00")) return next(error(400));
        if (prova <= my.root) return next(error(403));
        var stat = fs.statSync(prova);
        if (stat) {
            if (STORY.mtime && STORY.mtime === stat.mtime.getTime() && STORY.path === prova) return res.send(STORY.body);
            if (stat.isDirectory() === !1) return my.exclude !== !1 && my.exclude.test(prova) ? next(error(404)) : my.statico(req, res, next);
            var head;
            my.json === !0 ? head = Object.create(null) : (head = header, head = head.replace(/{{path}}/g, paths), 
            "/" != paths && (head += '<a href="../">../</a>\n'));
            var files = fs.readdirSync(prova);
            if (files) {
                for (var after = "", i = 0, ii = files.length; ii > i; ++i) {
                    var file = files[i];
                    if (!(my.exclude !== !1 && my.exclude.test(file) || my.dotfiles === !0 && "." === file[0])) {
                        var stats = fs.statSync(prova + path.sep + file);
                        if (stats) {
                            var r = build(head, after, file, stats);
                            head = r[0], after = r[1];
                        }
                    }
                }
                return output(res, head, after, prova, stat);
            }
        }
        return my.statico(req, res, next);
    } : function(req, res, next) {
        if (my.strictMethod === !0 && "GET" !== req.method && "HEAD" !== req.method) return next(error(404));
        var paths = decodeURIComponent(parse(req).pathname).replace(/\/{2,}/, "/"), prova = path.normalize(path.join(my.root, paths));
        return ~prova.indexOf("\x00") ? next(error(400)) : prova <= my.root ? next(error(403)) : fs.stat(prova, function(err, stat) {
            if (err) return next(error(err));
            if (STORY.mtime && STORY.mtime === stat.mtime.getTime() && STORY.path === prova) return res.send(STORY.body);
            if (stat.isDirectory() === !1) return my.exclude !== !1 && my.exclude.test(prova) ? next(error(404)) : my.statico(req, res, next);
            var head;
            return my.json === !0 ? head = Object.create(null) : (head = header, head = head.replace(/{{path}}/g, paths), 
            "/" != paths && (head += '<a href="../">../</a>\n')), fs.readdir(prova, function(err, files) {
                if (err) return next(error(err));
                for (var after = "", cc = files.length - 1, i = 0, ii = files.length; ii > i; ++i) !function(file) {
                    return my.exclude !== !1 && my.exclude.test(file) ? 0 === cc ? output(res, head, after, prova, stat) : void --cc : my.dotfiles === !0 && "." === file[0] ? 0 === cc ? output(res, head, after, prova, stat) : void --cc : fs.stat(prova + path.sep + file, function(err, stats) {
                        if (err) return next(error(err));
                        var r = build(head, after, file, stats);
                        return head = r[0], after = r[1], 0 === cc ? output(res, head, after, prova, stat) : void --cc;
                    });
                }(files[i]);
            });
        });
    };
}

function index(root, opt) {
    if (!root) throw new TypeError("root path required");
    var r = path.resolve(root);
    if ("/" == r[r.length - 1] && (r = r.substr(0, r.length - 1)), !fs.existsSync(root)) throw new Error("path not exists");
    if (!fs.statSync(r).isDirectory()) throw new Error("path is not a directory");
    var options = opt || Object.create(null), my = {
        root: r,
        exclude: options.exclude || !1,
        dotfiles: options.dotfiles !== !1,
        date: options.date !== !1,
        size: options.size !== !1,
        priority: options.priority !== !1,
        cache: options.cache !== !1,
        strictMethod: Boolean(options.strictMethod),
        sync: Boolean(options.sync),
        json: Boolean(options.json),
        "static": options["static"] === !1 ? !1 : options["static"] || {}
    };
    return my.dotfiles === !1 && options["static"] !== !1 && (my["static"].dotfiles = "allow"), 
    my.statico = my["static"] === !1 ? function(req, res, next) {
        return next();
    } : serve(r, my["static"]), wrapper(my);
}

var status = require("http").STATUS_CODES, path = require("path"), fs = require("fs"), parse = require("parseurl"), serve = require("serve-static"), header = '<html>\n<head><title>Index of {{path}}</title></head>\n<body bgcolor="white">\n<h1>Index of {{path}}</h1><hr><pre>\n', footer = "</pre><hr></body>\n</html>\n", month = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];

module.exports = index;
