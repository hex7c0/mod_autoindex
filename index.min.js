"use strict";

var status = require("http").STATUS_CODES, path = require("path"), fs = require("fs"), parse = require("parseurl"), serve = require("serve-static"), header = '<html>\n<head><title>Index of {{path}}</title></head>\n<body bgcolor="white">\n<h1>Index of {{path}}</h1><hr><pre>\n', footer = "</pre><hr></body>\n</html>\n", month = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];

function multiple(length, limit) {
    var space = "";
    if (limit < length) return space;
    for (var i = 0, ii = limit - length; i < ii; ++i) space += " ";
    return space;
}

function error(e) {
    return !1 === isNaN(e) ? new Error(status[e]) : new Error("ENAMETOOLONG" === e.code ? status[414] : status[404]);
}

function pad(num) {
    var norm = Math.abs(Math.floor(num));
    return (norm < 10 ? "0" : "") + norm;
}

function wrapper(my) {
    function output(res, head, after, paths, stat) {
        !0 === my.json ? (res.send(head), STORY.body = head) : (head += after + footer, 
        res.send(head), STORY.body = head), !0 === my.cache && (STORY.path = paths, STORY.mtime = stat.mtime.getTime());
    }
    var STORY = Object.create(null), build = function(head, after, file, stats) {
        var h, size, hea = head, afte = after, fil = file;
        if (!0 === stats.isDirectory() ? (size = "-", fil += "/") : size = String(stats.size), 
        h = '<a href="' + fil + '">' + fil + "</a>", h += multiple(fil.length, 50), !0 === my.date) {
            var d = new Date(stats.mtime);
            h += pad(d.getDate()) + "-" + month[d.getMonth()] + "-" + d.getFullYear(), h += " " + pad(d.getHours()) + ":" + pad(d.getMinutes()), 
            h += multiple(size.length, 20);
        }
        return !0 === my.size && (h += size), h += "\n", !0 === my.priority ? "-" === size ? hea += h : afte += h : hea += h, 
        [ hea, afte ];
    };
    return !0 === my.json && (build = function(head, after, file, stats) {
        var size, fil = file;
        if (!0 === stats.isDirectory() ? (size = "-", fil += "/") : size = String(stats.size), 
        head[fil] = Object.create(null), !0 === my.date) {
            var d = new Date(stats.mtime), h = pad(d.getDate()) + "-" + month[d.getMonth()] + "-" + d.getFullYear();
            h += " " + pad(d.getHours()) + ":" + pad(d.getMinutes()), head[fil].mtime = h;
        }
        return !0 === my.size && (head[fil].size = size), [ head, null ];
    }), !0 === my.sync ? function(req, res, next) {
        if (!0 === my.strictMethod && "GET" !== req.method && "HEAD" !== req.method) return next(error(404));
        var paths = decodeURIComponent(parse(req).pathname).replace(/\/{2,}/, "/"), prova = path.normalize(path.join(my.root, paths));
        if (~prova.indexOf("\0")) return next(error(400));
        if (prova <= my.root) return next(error(403));
        var stat = fs.statSync(prova);
        if (stat) {
            if (STORY.mtime && STORY.mtime === stat.mtime.getTime() && STORY.path === prova) return res.send(STORY.body);
            if (!1 === stat.isDirectory()) return !1 !== my.exclude && my.exclude.test(prova) ? next(error(404)) : my.statico(req, res, next);
            var head;
            !0 === my.json ? head = Object.create(null) : (head = (head = header).replace(/{{path}}/g, paths), 
            "/" != paths && (head += '<a href="../">../</a>\n'));
            var files = fs.readdirSync(prova);
            if (files) {
                for (var after = "", i = 0, ii = files.length; i < ii; ++i) {
                    var file = files[i];
                    if ((!1 === my.exclude || !my.exclude.test(file)) && (!0 !== my.dotfiles || "." !== file[0])) {
                        var stats = fs.statSync(prova + path.sep + file);
                        if (stats) {
                            var r = build(head, after, file, stats);
                            head = r[0], after = r[1];
                        }
                    }
                }
                return output(res, head, after, prova, stat);
            }
        }
        return my.statico(req, res, next);
    } : function(req, res, next) {
        if (!0 === my.strictMethod && "GET" !== req.method && "HEAD" !== req.method) return next(error(404));
        var paths = decodeURIComponent(parse(req).pathname).replace(/\/{2,}/, "/"), prova = path.normalize(path.join(my.root, paths));
        return ~prova.indexOf("\0") ? next(error(400)) : prova <= my.root ? next(error(403)) : fs.stat(prova, function(err, stat) {
            if (err) return next(error(err));
            if (STORY.mtime && STORY.mtime === stat.mtime.getTime() && STORY.path === prova) return res.send(STORY.body);
            if (!1 === stat.isDirectory()) return !1 !== my.exclude && my.exclude.test(prova) ? next(error(404)) : my.statico(req, res, next);
            var head;
            return !0 === my.json ? head = Object.create(null) : (head = (head = header).replace(/{{path}}/g, paths), 
            "/" != paths && (head += '<a href="../">../</a>\n')), fs.readdir(prova, function(err, files) {
                if (err) return next(error(err));
                for (var after = "", cc = files.length - 1, i = 0, ii = files.length; i < ii; ++i) !function(file) {
                    !1 !== my.exclude && my.exclude.test(file) ? 0 === cc ? output(res, head, after, prova, stat) : --cc : !0 === my.dotfiles && "." === file[0] ? 0 === cc ? output(res, head, after, prova, stat) : --cc : fs.stat(prova + path.sep + file, function(err, stats) {
                        if (err) return next(error(err));
                        var r = build(head, after, file, stats);
                        if (head = r[0], after = r[1], 0 === cc) return output(res, head, after, prova, stat);
                        --cc;
                    });
                }(files[i]);
            });
        });
    };
}

function index(root, opt) {
    if (!root) throw new TypeError("root path required");
    var r = path.resolve(root);
    if ("/" == r[r.length - 1] && (r = r.substr(0, r.length - 1)), !fs.existsSync(root)) throw new Error("path not exists");
    if (!fs.statSync(r).isDirectory()) throw new Error("path is not a directory");
    var options = opt || Object.create(null), my = {
        root: r,
        exclude: options.exclude || !1,
        dotfiles: !1 !== options.dotfiles,
        date: !1 !== options.date,
        size: !1 !== options.size,
        priority: !1 !== options.priority,
        cache: !1 !== options.cache,
        strictMethod: Boolean(options.strictMethod),
        sync: Boolean(options.sync),
        json: Boolean(options.json),
        static: !1 !== options.static && (options.static || {})
    };
    return !1 === my.dotfiles && !1 !== options.static && (my.static.dotfiles = "allow"), 
    my.statico = !1 === my.static ? function(req, res, next) {
        return next();
    } : serve(r, my.static), wrapper(my);
}

module.exports = index;
